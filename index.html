<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Party Records</title>
    
    <!-- AG-Grid CSS -->
    <link rel="stylesheet" href="https://unpkg.com/ag-grid-community@31.0.0/styles/ag-grid.css">
    <link rel="stylesheet" href="https://unpkg.com/ag-grid-community@31.0.0/styles/ag-theme-alpine-dark.css">
    
    <!-- AG-Grid JS -->
    <script src="https://unpkg.com/ag-grid-community@31.0.0/dist/ag-grid-community.min.js"></script>

    <!-- Font Library -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Audiowide&family=Electrolize&family=Michroma&family=Poiret+One&family=Syncopate:wght@400;700&family=Megrim&family=Wallpoet&family=Monoton&family=Bungee&family=Righteous&family=Russo+One&family=Fredoka+One&family=Changa+One&family=Bebas+Neue&family=Stalinist+One&family=Black+Ops+One&family=Faster+One&family=Warnes&family=Gruppo&family=Jockey+One&family=Abril+Fatface&family=Ultra&family=Bowlby+One&family=Bowlby+One+SC&family=Bungee+Shade&family=Bungee+Outline&family=Bungee+Inline&family=Bungee+Hairline&family=Creepster&family=Nosifer&family=Butcherman&family=Eater&family=Metal+Mania&family=Caesar+Dressing&family=Fascinate&family=Fascinate+Inline&family=Metamorphous&family=Snowburst+One&family=Flavors&family=Lacquer&family=Vampiro+One&family=Ewert&family=Skranji:wght@400;700&family=UnifrakturMaguntia&family=MedievalSharp&family=Cinzel+Decorative:wght@400;700&family=Almendra+Display&family=Fredericka+the+Great&family=Griffy&family=Trade+Winds&family=Pirata+One&family=Jolly+Lodger&family=New+Rocker&family=Rye&family=Fontdiner+Swanky&family=Macondo&family=Macondo+Swash+Caps&family=Spicy+Rice&family=Underdog&family=Henny+Penny&family=Bangers&family=Luckiest+Guy&family=Freckle+Face&family=Kranky&family=Special+Elite&family=Press+Start+2P&family=VT323&family=Share+Tech&family=Aldrich&family=Exo:wght@400;700&family=Rajdhani:wght@400;700&family=Space+Mono:wght@400;700&family=Oxanium:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #1a1a1a;
            --secondary-color: #2a2a2a;
            --accent-color-1: #0ec5c56b;  
            --accent-color-2: #ffdab9;  
            --accent-color-3: #d0f0c0; 
            --text-color: #ffffff;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, var(--primary-color), #2c2c2c);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .title-container {
            margin-bottom: 30px;
            padding: 10px 0;
            border-bottom: 2px solid var(--secondary-color);
        }

        .main-title {
            font-size: 1.6rem;
            color: var(--text-color);
            text-align: center;
            margin: 15px 0;
            padding: 30px 0;
            width: 90%;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
            transition: all 0.4s ease;
            letter-spacing: 20px;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
            transform-origin: center;
        }

        .main-title::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.8s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-title {
                font-size: 2.4rem;
                width: 95%;
                padding: 20px 0;
                letter-spacing: 1px;
            }
        }

        @media (max-width: 480px) {
            .main-title {
                font-size: 1.8rem;
                padding: 15px 0;
                letter-spacing: 0.5px;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-title {
                font-size: 2.4rem;
                width: 95%;
                padding: 20px 0;
                letter-spacing: 1px;
            }
        }

        @media (max-width: 480px) {
            .main-title {
                font-size: 1.8rem;
                padding: 15px 0;
                letter-spacing: 0.5px;
            }
        }

        .search-subheading {
            text-align: center;
            margin-bottom: 15px;
            font-size: 1.2em;
            color: rgb(138, 138, 138);
        }
        
        .search-section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            position: relative;
        }
        
        @keyframes unfold {
            from {
                max-height: 0;
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                max-height: 200px;
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        #global-search-results {
            position: absolute;
            top: 100%;
            left: 20px;
            right: 20px;
            background-color: var(--secondary-color);
            border-top: none;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            animation: unfold 0.3s ease-out;
        }
        
        .search-result-item {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .search-result-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .search-result-item img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
        }
        
        .arrow {
            display: inline-block;
            animation: bounce 2s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateY(-1px); }
            to { transform: translateY(4px); }
        }
        
        #global-player-search {
            width: calc(100% - 40px);
            padding: 10px 20px;
            border: 1px solid var(--accent-color-1);
            border-radius: 5px;
            background-color: var(--secondary-color);
            color: var(--text-color);
            font-size: 16px;
            margin: 0 auto;
            display: block;
        }
        
        #global-player-search:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(168, 216, 234, 0.5);
        }
        
        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }
        
        .dropdown, .search-container {
            flex: 1;
            max-width: calc(50% - 10px);
        }

        #minigame-select, #player-search {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--accent-color-1);
            border-radius: 5px;
            background-color: var(--secondary-color);
            color: var(--text-color);
            font-size: 16px;
            box-sizing: border-box;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23ffffff" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        #minigame-select:focus, #player-search:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(168, 216, 234, 0.5);
        }

        #player-search::placeholder {
            color: #aaa;
        }

        /* AG-Grid Custom Styling */
        .ag-theme-alpine-dark {
            --ag-background-color: var(--secondary-color);
            --ag-header-background-color: #000000;
            --ag-odd-row-background-color: #333333;
            --ag-row-hover-color: rgba(255, 255, 255, 0.05);
            --ag-selected-row-background-color: rgba(14, 197, 197, 0.2);
            --ag-border-color: var(--secondary-color);
            --ag-header-column-separator-color: var(--secondary-color);
            --ag-cell-horizontal-border: solid var(--secondary-color);
            --ag-font-family: Arial, sans-serif;
            --ag-font-size: 14px;
            --ag-foreground-color: var(--text-color);
            --ag-header-foreground-color: var(--text-color);
            border: none;
        }

        .ag-header-cell-sortable:hover {
            background-color: #1a1a1a !important;
        }

        .ag-header-cell.ag-header-cell-sorted-asc,
        .ag-header-cell.ag-header-cell-sorted-desc {
            background-color: var(--accent-color-1) !important;
            color: var(--primary-color) !important;
        }

        .ag-row:hover .ag-cell {
            color: var(--accent-color-2) !important;
        }

        .player-avatar {
            width: 32px;
            height: 32px;
            vertical-align: middle;
            margin-right: 10px;
        }

        .player-name {
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .player-name:hover {
            color: var(--accent-color-1);
        }

        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color-3);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #records-grid {
            height: 500px;
            width: 100%;
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
        }

        #records-grid.loaded {
            opacity: 1;
        }

        .rank-1 {
            color: rgb(226, 173, 0) !important;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(226, 155, 0, 0.5);
        }
        .rank-2 {
            color: rgb(214, 237, 243) !important;
            font-weight: bold;
            text-shadow: 0 0 4px rgba(212, 246, 255, 0.5);
        }
        .rank-3 {
            color: rgb(175, 106, 2) !important;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(182, 111, 4, 0.5);
        }
        .rank-other {
            color: #A0A0A0 !important;
        }

        .video-link {
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            transition: opacity 0.3s ease;
        }

        .video-link:hover {
            opacity: 0.7;
        }

        .video-links-container {
            margin-top: 20px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .video-links-container h3 {
            color: var(--accent-color-1);
            margin-bottom: 15px;
        }

        .video-links-container h4 {
            color: var(--accent-color-2);
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .video-link-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            transition: background-color 0.3s ease;
            margin-bottom: 10px;
        }

        .video-link-item:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .video-link-player {
            flex-grow: 1;
            color: var(--text-color);
        }

        .video-link-time {
            margin-right: 15px;
            color: var(--accent-color-3);
        }

        .video-link-button {
            padding: 5px 10px;
            background-color: var(--accent-color-1);
            color: var(--primary-color);
            text-decoration: none;
            border-radius: 3px;
            transition: background-color 0.3s ease;
        }

        .video-link-button:hover {
            background-color: var(--accent-color-2);
        }

        .legend {
            margin-top: 10px;
            color: rgb(168, 168, 168);
            font-size: 0.9em;
            text-align: center;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: var(--secondary-color);
            margin: 5% auto;
            padding: 30px;
            border: 1px solid #444;
            width: 90%;
            max-width: 800px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .close {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: var(--accent-color-2);
        }

        .player-profile-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            padding-right: 40px;
        }

        .player-avatar-name {
            display: flex;
            align-items: center;
        }

        .player-avatar-name img {
            width: 100px;
            height: 100px;
            margin-right: 20px;
            border-radius: 8px;
        }

        .player-avatar-name h2 {
            margin: 0;
            font-size: 24px;
        }

        .player-prefix {
            font-weight: bold;
            margin-right: 5px;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
        }

        .player-stats {
            text-align: right;
        }

        .player-stats p {
            margin: 5px 0;
            font-size: 14px;
        }

        .player-stats p strong {
            color: var(--accent-color-1);
        }

        .profile-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 20px;
        }

        .profile-table th,
        .profile-table td {
            border: 1px solid #444;
            padding: 10px;
            text-align: left;
        }

        .profile-table th {
            background-color: var(--primary-color);
            font-weight: bold;
        }

        .profile-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .minigame-section {
            margin-top: 30px;
        }

        .minigame-section h3 {
            color: var(--accent-color-2);
            margin-bottom: 10px;
        }

        .expand-button {
            background: none;
            border: none;
            color: var(--accent-color-1);
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 0.9em;
            margin-top: 10px;
            transition: color 0.3s ease;
        }

        .expand-button:hover {
            color: var(--accent-color-2);
        }

        .expand-icon {
            margin-right: 5px;
        }

        .site-footer {
            margin-top: 40px;
            padding: 20px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(0, 0, 0, 0.2);
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .footer-separator {
            margin: 0 10px;
            color: rgba(255, 255, 255, 0.3);
        }

        .site-footer a {
            color: var(--accent-color-1);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .site-footer a:hover {
            color: var(--accent-color-2);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .controls-container {
                flex-direction: column;
                align-items: stretch;
            }

            .dropdown,
            .search-container {
                max-width: none;
                margin-bottom: 10px;
            }

            .player-profile-header {
                flex-direction: column;
            }

            .player-stats {
                text-align: left;
                margin-top: 15px;
            }

            .main-title {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .player-avatar-name img {
                width: 80px;
                height: 80px;
            }
        }

        .search-result-item.highlighted {
            background-color: rgba(14, 197, 197, 0.3) !important;
            border-left: 3px solid var(--accent-color-1);
        }

        .search-result-item {
            transition: background-color 0.2s ease;
        }


        /* Hotkey Indicators */
        .hotkey-hints {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
            pointer-events: none;
        }

        .hotkey-hint {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(42, 42, 42, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
            opacity: 0;
            transform: translateX(20px);
            animation: slideInHint 0.5s ease-out forwards;
            transition: all 0.3s ease;
        }

        .hotkey-hint:nth-child(1) { animation-delay: 0.1s; }
        .hotkey-hint:nth-child(2) { animation-delay: 0.2s; }
        .hotkey-hint:nth-child(3) { animation-delay: 0.3s; }

        @keyframes slideInHint {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .hotkey-hint:hover {
            background: rgba(42, 42, 42, 0.95);
            border-color: var(--accent-color-1);
            transform: scale(1.02);
            pointer-events: auto;
            cursor: help;
        }

        .hotkey-key {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--accent-color-1);
            text-shadow: 0 0 2px rgba(14, 197, 197, 0.3);
            min-width: 20px;
            text-align: center;
        }

        .hotkey-hint.modal-open {
            opacity: 0.3;
        }

        .hotkey-hint.modal-hint {
            opacity: 1 !important;
            background: rgba(14, 197, 197, 0.1);
            border-color: var(--accent-color-1);
        }

        /* Search bar enhancement */
        .search-enhancement {
            position: relative;
        }

        .search-hotkey-indicator {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 4px;
            pointer-events: none;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .search-hotkey-indicator .hotkey-key {
            font-size: 0.7rem;
            padding: 1px 4px;
            background: rgba(255, 255, 255, 0.05);
        }

        #global-player-search:focus + .search-hotkey-indicator {
            opacity: 0.8;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hotkey-hints {
                bottom: 10px;
                right: 10px;
                font-size: 0.8rem;
            }

            .hotkey-hint {
                padding: 6px 8px;
            }

            .hotkey-key {
                padding: 1px 4px;
                font-size: 0.7rem;
            }
        }

        @media (max-width: 480px) {
            .hotkey-hints {
                display: none; /* Hide on very small screens */
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="title-container">
            <h1 class="main-title">mehr mp stats halt</h1>
        </div>

        <div class="search-section">
            <div class="search-subheading">
                <span class="arrow">full data</span>
            </div>
            <div class="search-enhancement">
                <input type="text" id="global-player-search" placeholder="records(<player>)">
                <div class="search-hotkey-indicator">
                    <span class="hotkey-key">â†µ</span>
                </div>
            </div>
            <div id="global-search-results"></div>
        </div>

        <div class="controls-container">
            <div class="dropdown">
                <select id="minigame-select">
                    <option value="BlockhÃ¼pfer">Block Jump</option>
                    <option value="Buntes Chaos">Colorful Chaos</option>
                    <option value="TodeswÃ¼rfel">Death Cube</option>
                    <option value="Duelle">Duels</option>
                    <option value="Drachenflucht">Dragon Escape</option>
                    <option value="Freier Fall">Dropper</option>
                    <option value="Elytrarennen">Elytra Race</option>
                    <option value="Frostiger Pfad">Frozen Path</option>
                    <option value="Waffenfolge">Gungame</option>
                    <option value="Pferderennen" selected>Horse Race</option>
                    <option value="Parkour">Parkour</option>
                    <option value="KletterkÃ¶nig">King of the Hill</option>
                    <option value="Lasertag">Lasertag</option>
                    <option value="Minengefecht">Mine Battle</option>
                    <option value="Minenfeld">Minefield</option>
                    <option value="Skywars">Skywars</option>
                    <option value="Survivalgames">Survivalgames</option>
                    <option value="Einer im KÃ¶cher">One in the Chamber</option>
                    <option value="Paintball">Paintball</option>
                    <option value="Replika">Replica</option>
                    <option value="Ampelrennen">Red Light, Green Light</option>
                    <option value="SchieÃŸstand">Shooting Range</option>
                    <option value="Spleef">Spleef</option>
                    <option value="Wettrennen">Speed Race</option>
                    <option value="Sammelwahn">Too many items</option>
                    <option value="Runterpurzeln">Tumble Tactics</option>
                    <option value="Hoch hinaus">Up High</option>
                    <option value="Mauerfall">Mauerfall</option>
                    <option value="Turmroulette">Turmroulette</option>
                </select>
            </div>
            <div class="search-container">
                <input type="text" id="player-search" placeholder="filter scoreboard...">
            </div>
        </div>

        <div id="loading-animation" class="loading">
            <div class="spinner"></div>
            <p id="loading-text">Loading data and avatars...</p>
        </div>

        <div id="records-grid" class="ag-theme-alpine-dark"></div>
        <div id="legend-container"></div>
        <div id="video-links-container" class="video-links-container"></div>

        <!-- Player Profile Modal -->
        <div id="player-profile-modal" class="modal">
            <div class="modal-content">
                <span class="close" id="close-modal">&times;</span>
                <div id="player-profile-content"></div>
            </div>
        </div>

        <footer class="site-footer">
            <div class="footer-content">
                <span>Data as of: <time datetime="2025-07-10T12:00:00Z">12 Jul, 2025</time></span>
                <span class="footer-separator">|</span>
                <a href="https://github.com/Fflopse/MCP-Records" target="_blank" rel="noopener noreferrer">GitHub Repository</a>
                <span class="footer-separator">|</span>
                <a href="https://github.com/Fflopse/MCP-Records/blob/main/data-analysis/records_data.json">Raw Data</a>
                <span class="footer-separator">|</span>
                <a href="mailto:contact@fflopse.de">Contact</a>
            </div>
        </footer>
    </div>

    <script>
        // Sample data structure - replace with your actual data loading
        const sampleData = [
            {
                "name": "Ex4cted",
                "minigame": "Runterpurzeln",
                "scores": {"Space": 49.26},
                "best_score": 49.26
            },
            {
                "name": "swiffle",
                "minigame": "Runterpurzeln",
                "scores": {"Space": 58.713},
                "best_score": 58.713
            },
            {
                "name": "juvona",
                "minigame": "Runterpurzeln",
                "scores": {"Space": 134.32},
                "best_score": 134.32
            },
            {
                "name": "__egE",
                "minigame": "Sammelwahn",
                "scores": {
                    "Sum": 452.0,
                    "Dichter Wald": 25.0,
                    " Bambusdschungel": 20.0,
                    " Birkenwald": 27.0
                },
                "best_score": 452.0
            }
        ];

        // Configuration objects
        const minigameSortDirections = {
            "BlockhÃ¼pfer": "asc",
            "Buntes Chaos": "desc",
            "TodeswÃ¼rfel": "asc",
            "Duelle": "desc",
            "Freier Fall": "asc",
            "Elytrarennen": "asc",
            "Frostiger Pfad": "asc",
            "Waffenfolge": "asc",
            "Pferderennen": "asc",
            "Parkour": "asc",
            "KletterkÃ¶nig": "asc",
            "Lasertag": "desc",
            "Minengefecht": "desc",
            "Minenfeld": "asc",
            "Skywars": "desc",
            "Survivalgames": "desc",
            "Einer im KÃ¶cher": "desc",
            "Paintball": "desc",
            "Replika": "asc",
            "Ampelrennen": "asc",
            "SchieÃŸstand": "desc",
            "Spleef": "desc",
            "Wettrennen": "asc",
            "Sammelwahn": "desc",
            "Hoch hinaus": "asc",
            "Runterpurzeln": "asc",
            "Mauerfall": "desc",
            "Turmroulette": "desc",
        };

        const cutoffValues = {
            "TodeswÃ¼rfel": {"Street": 25.0},
            "Wettrennen": {
                "Blossom Canyon": 77.0,
                "Green Hills": 62.5
            },
            "Freier Fall": {"Underground": 19.0},
            "Hoch hinaus": {"Global": 39.0},
            "Pferderennen": {
                "Ancient Falls": 82.0
            },
            "Minenfeld": {"Ice Cave": 24.0}
        };

        const videoLinks = {
            "BlockhÃ¼pfer": {
                "City": [
                    {time: 20.577, player: "ReichesBrot", link: "https://youtu.be/I-v4fahzt00"}
                ]
            },
            "Pferderennen": {
                "City": [
                    {time: 63.320, player: "Fflopse", link: "https://youtu.be/JcA4LR3a2RY"}
                ]
            }
        };

        const prefixData = {
            "bauteam": {"prefix": "Â§f", "name": "Builder", "color": "#ffd300"},
            "supporter": {"prefix": "Â§f", "name": "Supporter", "color": "#54c9ff"},
            "default": {"prefix": "Â§f", "name": "Player", "color": "#9097a0"},
            "premium": {"prefix": "Â§f", "name": "Premium", "color": "#71d512"},
            "premium+": {"prefix": "Â§f", "name": "Premium+", "color": "#448e00"},
            "entwickler": {"prefix": "Â§f", "name": "Developer", "color": "#e6173d"},
            "content": {"prefix": "Â§f", "name": "Content", "color": "#ff0b74"},
            "translator": {"prefix": "Â§f", "name": "Translator", "color": "#03c988"},
            "vip": {"prefix": "Â§f", "name": "VIP", "color": "#ae00ff"},
            "moderator": {"prefix": "Â§f", "name": "Moderator", "color": "#0078ff"},
            "owner": {"prefix": "Â§f", "name": "Owner", "color": "#980c23"} 
        };

        // Global variables
        let gridApi;
        let gridOptions;
        let currentMinigame = "Pferderennen";
        let allData = [];
        let playerUUIDs = {};
        let playerInfoData = {};

        // Utility functions
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function getRankClass(rank) {
            if (rank === 1) return 'rank-1';
            if (rank === 2) return 'rank-2';
            if (rank === 3) return 'rank-3';
            return 'rank-other';
        }

        function calculateRank(allPlayersData, map, playerScore, sortDirection) {
            const validScores = allPlayersData
                .map(player => player.scores[map])
                .filter(score => score !== undefined && score !== null && score !== "-");

            const uniqueScores = [...new Set(validScores)];
            uniqueScores.sort((a, b) => sortDirection === "asc" ? a - b : b - a);

            return uniqueScores.indexOf(playerScore) + 1;
        }

        // Cell renderers
        function avatarCellRenderer(params) {
            const name = params.data.name;
            const uuid = playerUUIDs[name] || "8667ba71-b85a-4004-af54-457a9734eed7";
            const avatarUrl = `https://crafatar.com/avatars/${uuid}?size=32&overlay`;

            return `
                <div style="display: flex; align-items: center;">
                    <img src="${avatarUrl}" class="player-avatar" alt="${name}'s avatar">
                    <span class="player-name" onclick="showPlayerProfile('${name}')">${name}</span>
                </div>
            `;
        }

        function rankCellRenderer(params) {
            const rank = params.value;
            if (rank === "-" || rank === null || rank === undefined) {
                return `<span class="rank-other">-</span>`;
            }
            const rankClass = getRankClass(rank);
            return `<span class="${rankClass}">${rank}</span>`;
        }

        function scoreCellRenderer(params) {
            const value = params.value;
            if (value === undefined || value === null) return "-";

            const formattedValue = typeof value === 'number' ? value.toFixed(3) : value;
            const playerName = params.data.name;
            const mapName = params.colDef.field.replace('scores.', '');

            // Check for video links
            const videoInfo = videoLinks[currentMinigame] &&
                            videoLinks[currentMinigame][mapName] &&
                            videoLinks[currentMinigame][mapName].find(v => 
                                v.player === playerName && Math.abs(v.time - parseFloat(formattedValue)) < 0.001
                            );

            if (videoInfo) {
                return `<a href="${videoInfo.link}" target="_blank" class="video-link">${formattedValue}</a>`;
            }

            // Check if the value is better than the cutoff
            const cutoff = cutoffValues[currentMinigame] && cutoffValues[currentMinigame][mapName];
            if (cutoff !== undefined) {
                const sortDirection = minigameSortDirections[currentMinigame] || "desc";
                if ((sortDirection === "asc" && value < cutoff) || (sortDirection === "desc" && value > cutoff)) {
                    return `<span style="font-style: italic;">${formattedValue}*</span>`;
                }
            }

            return formattedValue;
        }

        // Grid setup functions
        function createColumnDefs(minigame, filteredData) {
            const allMapNames = new Set();
            filteredData.forEach(record => {
                Object.keys(record.scores || {}).forEach(mapName => {
                    allMapNames.add(mapName);
                });
            });

            // Calculate the width needed for the name column based on content
            const longestName = filteredData.reduce((longest, record) => 
                record.name.length > longest.length ? record.name : longest, ""
            );
            // Base width for avatar (40px) + padding (20px) + text width estimate (8px per char) + buffer (20px)
            const nameColumnWidth = Math.max(200, 40 + 20 + (longestName.length * 8) + 20);

            const columnDefs = [
                {
                    headerName: "Name",
                    field: "name",
                    cellRenderer: avatarCellRenderer,
                    pinned: 'left',
                    width: nameColumnWidth,
                    minWidth: nameColumnWidth,
                    maxWidth: nameColumnWidth + 50, // Allow some flexibility
                    sortable: false,
                    filter: false,
                    suppressSizeToFit: true, // Don't resize this column during sizeColumnsToFit
                    lockPosition: true
                },
                {
                    headerName: "Rank",
                    field: "rank",
                    cellRenderer: rankCellRenderer,
                    width: 70,
                    minWidth: 70,
                    maxWidth: 80,
                    sortable: false,
                    filter: false,
                    suppressSizeToFit: true
                }
            ];

            const sortDirection = minigameSortDirections[minigame] || "desc";

            Array.from(allMapNames).sort().forEach(mapName => {
                columnDefs.push({
                    headerName: mapName,
                    field: `scores.${mapName}`,
                    cellRenderer: scoreCellRenderer,
                    width: 120,
                    sortable: true,
                    filter: false,
                    // Restrict sorting to only the predefined direction
                    sortingOrder: [sortDirection],
                    valueGetter: params => {
                        return params.data.scores && params.data.scores[mapName] !== undefined
                            ? params.data.scores[mapName]
                            : null;
                    },
                    // Custom comparator to ensure null/undefined values are always at the bottom
                    comparator: (valueA, valueB, nodeA, nodeB, isInverted) => {
                        const aIsNull = (valueA === null || valueA === undefined);
                        const bIsNull = (valueB === null || valueB === undefined);

                        // If both are null, they're equal
                        if (aIsNull && bIsNull) return 0;

                        // For null handling, we want consistent behavior regardless of isInverted
                        // We'll return values that put nulls at bottom even when AG-Grid tries to invert
                        if (aIsNull && !bIsNull) {
                            // A is null, should go to bottom
                            // When descending (isInverted=true), AG-Grid will flip this, so we flip it first
                            return isInverted ? -999999 : 999999;
                        }
                        if (!aIsNull && bIsNull) {
                            // B is null, should go to bottom
                            // When descending (isInverted=true), AG-Grid will flip this, so we flip it first
                            return isInverted ? 999999 : -999999;
                        }

                        // For valid numbers, use simple numeric comparison
                        return valueA - valueB;
                    }
                });
            });

            return columnDefs;
        }

        function prepareRowData(minigame, filteredData) {
            if (filteredData.length === 0) return [];

            // Get all map names for this minigame
            const allMapNames = new Set();
            filteredData.forEach(record => {
                Object.keys(record.scores || {}).forEach(mapName => {
                    allMapNames.add(mapName);
                });
            });

            const sortDirection = minigameSortDirections[minigame] || "desc";
            const firstMapName = Array.from(allMapNames).sort()[0];

            // Sort data by first map using the same logic as the AG-Grid comparator
            const sortedData = [...filteredData].sort((a, b) => {
                const aScore = a.scores && a.scores[firstMapName];
                const bScore = b.scores && b.scores[firstMapName];

                const aIsNull = (aScore === null || aScore === undefined);
                const bIsNull = (bScore === null || bScore === undefined);

                // If both are null, they're equal
                if (aIsNull && bIsNull) {
                    return 0;
                }

                // Null values always go to bottom regardless of sort direction
                if (aIsNull && !bIsNull) {
                    return 1; // A goes after B (to the bottom)
                }
                if (!aIsNull && bIsNull) {
                    return -1; // B goes after A (to the bottom)
                }

                // Both values are valid numbers - sort normally
                if (sortDirection === "asc") {
                    return aScore - bScore; // Ascending: smaller numbers first
                } else {
                    return bScore - aScore; // Descending: larger numbers first
                }
            });

            // Add ranks - skip null/undefined scores for ranking
            let rank = 1;
            let lastScore = null;
            let tieCount = 0;

            sortedData.forEach((row, index) => {
                const score = row.scores && row.scores[firstMapName];
                const scoreIsNull = (score === null || score === undefined);

                if (scoreIsNull) {
                    // Null scores don't get a rank, they get a dash
                    row.rank = "-";
                } else {
                    // Only rank valid scores
                    if (lastScore !== null && score !== lastScore) {
                        rank += tieCount + 1;
                        tieCount = 0;
                    } else if (lastScore !== null && score === lastScore) {
                        tieCount++;
                    }

                    row.rank = rank;
                    lastScore = score;
                }
            });

            return sortedData;
        }

        function updateGrid(minigame) {
            console.log('ðŸ”„ Updating grid for minigame:', minigame);
            currentMinigame = minigame;
            
            // Clear search
            document.getElementById('player-search').value = '';
            
            // Show loading
            document.getElementById('loading-animation').style.display = 'flex';
            document.getElementById('records-grid').style.opacity = '0';

            setTimeout(() => {
                const filteredData = allData.filter(record => record.minigame === minigame);
                console.log('Filtered data for', minigame + ':', filteredData.length, 'records');
                
                if (filteredData.length === 0) {
                    console.log('âš ï¸ No data found for minigame:', minigame);
                    if (gridApi) {
                        // Use the new API method instead of deprecated setRowData
                        gridApi.setGridOption('rowData', []);
                    }
                    document.getElementById('loading-animation').style.display = 'none';
                    document.getElementById('records-grid').style.opacity = '1';
                    return;
                }

                const columnDefs = createColumnDefs(minigame, filteredData);
                const rowData = prepareRowData(minigame, filteredData);
                
                console.log('Column definitions:', columnDefs.length, 'columns');
                console.log('Row data:', rowData.length, 'rows');

                if (gridApi) {
                    // Use new API methods
                    gridApi.setGridOption('columnDefs', columnDefs);
                    gridApi.setGridOption('rowData', rowData);

                    // Auto-sort by first score column
                    const firstScoreCol = columnDefs.find(col => col.field && col.field.startsWith('scores.'));
                    if (firstScoreCol) {
                        const sortDirection = minigameSortDirections[minigame] || 'desc';
                        console.log('Auto-sorting by:', firstScoreCol.field, 'direction:', sortDirection);
                        gridApi.applyColumnState({
                            state: [{ colId: firstScoreCol.field, sort: sortDirection }],
                            defaultState: { sort: null }
                        });
                    }
                    
                    // Fit columns to view, but preserve name column width
                    setTimeout(() => {
                        // Auto-size the name column to fit content perfectly
                        gridApi.autoSizeColumns(['name'], false);
                        
                        // Then fit the remaining columns
                        setTimeout(() => {
                            gridApi.sizeColumnsToFit();
                        }, 50);
                    }, 100);
                }

                // Update video links and legend
                displayVideoLinks(minigame);
                updateLegend(rowData);

                document.getElementById('loading-animation').style.display = 'none';
                document.getElementById('records-grid').style.opacity = '1';
                
                console.log('Grid update complete');
            }, 150);
        }

        function displayVideoLinks(minigame) {
            const container = document.getElementById('video-links-container');
            container.innerHTML = '';

            if (!videoLinks[minigame] || Object.keys(videoLinks[minigame]).length === 0) {
                return;
            }

            let html = '<h3>Clips</h3>';
            for (const [map, videos] of Object.entries(videoLinks[minigame])) {
                html += `<h4>${map}</h4>`;
                for (const video of videos) {
                    const uuid = playerUUIDs[video.player] || "8667ba71-b85a-4004-af54-457a9734eed7";
                    const avatarUrl = `https://crafatar.com/avatars/${uuid}?size=32&overlay`;
                    html += `
                        <div class="video-link-item">
                            <img src="${avatarUrl}" alt="${video.player}'s avatar" class="player-avatar">
                            <span class="video-link-player">${video.player}</span>
                            <span class="video-link-time">${video.time.toFixed(3)}</span>
                            <a href="${video.link}" target="_blank" class="video-link-button">Watch</a>
                        </div>
                    `;
                }
            }
            container.innerHTML = html;
        }

        function updateLegend(data) {
            const container = document.getElementById('legend-container');
            
            // Check if any records are annotated
            const hasAnnotatedRecords = data.some(row =>
                Object.entries(row.scores || {}).some(([map, score]) => {
                    const cutoff = cutoffValues[currentMinigame] && cutoffValues[currentMinigame][map];
                    if (cutoff !== undefined) {
                        const sortDirection = minigameSortDirections[currentMinigame] || "desc";
                        return (sortDirection === "asc" && score < cutoff) || (sortDirection === "desc" && score > cutoff);
                    }
                    return false;
                })
            );

            if (hasAnnotatedRecords) {
                container.innerHTML = `
                    <div class="legend">
                        * Indicates a score that is not reproducible in legitimate play at the current state of the map.
                    </div>
                `;
            } else {
                container.innerHTML = '';
            }
        }

        // Player profile functions
        function createPlayerProfile(playerName) {
            const playerData = allData.filter(record => record.name === playerName);
            const playerInfo = playerInfoData[playerName];

            // Determine the correct prefix
            const prefixInfo = playerInfo && prefixData[playerInfo.rank?.toLowerCase()]
                ? prefixData[playerInfo.rank.toLowerCase()]
                : prefixData.default;
            const prefixColor = prefixInfo.color;

            let profileHTML = `
                <div class="player-profile-header">
                    <div class="player-avatar-name">
                        <img src="https://starlightskins.lunareclipse.studio/render/default/${playerUUIDs[playerName] || 'Alex'}/face"
                            alt="${playerName}'s head"
                            onerror="this.src='https://starlightskins.lunareclipse.studio/render/default/Alex/face'">
                        <h2>
                            <span class="player-prefix" style="background-color: ${prefixColor};">${prefixInfo.name}</span>
                            ${playerName}
                        </h2>
                    </div>`;

            if (playerInfo && playerInfo.minecraft_party) {
                const gameWinPercentage = ((playerInfo.minecraft_party['Gewonnene Spiele'] / playerInfo.minecraft_party['Gespielte Spiele'])* 100).toFixed(2);
                const minigameWinPercentage = ((playerInfo.minecraft_party['Gewonnene Minispiele'] / playerInfo.minecraft_party['Gespielte Minispiele'])* 100).toFixed(2);

                profileHTML += `
                    <div class="player-stats">
                        <p><strong>alltime#:</strong> ${playerInfo.minecraft_party['Rang']}</p>
                        <p><strong>game%:</strong> ${gameWinPercentage}%</p>
                        <p><strong>minigame%:</strong> ${minigameWinPercentage}%</p>
                    </div>`;
            }

            profileHTML += `</div>`;

            const minigames = [...new Set(playerData.map(record => record.minigame))];
            let hasAnnotatedRecords = false;

            minigames.forEach((minigame, index) => {
                const minigameData = playerData.find(record => record.minigame === minigame);
                if (minigameData && minigameData.scores) {
                    const allPlayersData = allData.filter(record => record.minigame === minigame);

                    profileHTML += `
                        <div class="minigame-section">
                            <h3>${minigame}</h3>
                            <table class="profile-table" id="minigame-table-${index}">
                                <thead>
                                    <tr>
                                        <th>Map</th>
                                        <th>Score</th>
                                        <th>Rank</th>
                                    </tr>
                                </thead>
                                <tbody>`;

                    Object.entries(minigameData.scores).forEach(([map, score]) => {
                        const sortDirection = minigameSortDirections[minigame] || "desc";
                        const playerRank = calculateRank(allPlayersData, map, score, sortDirection);
                        const rankClass = getRankClass(playerRank);

                        // Check if the score is better than the cutoff
                        const cutoff = cutoffValues[minigame] && cutoffValues[minigame][map];
                        let scoreDisplay = score;
                        if (cutoff !== undefined &&
                            ((sortDirection === "asc" && score < cutoff) ||
                            (sortDirection === "desc" && score > cutoff))) {
                            scoreDisplay = `<span style="font-style: italic;">${score}*</span>`;
                            hasAnnotatedRecords = true;
                        }

                        profileHTML += `
                            <tr>
                                <td>${map}</td>
                                <td>${scoreDisplay}</td>
                                <td class="${rankClass}">${playerRank}</td>
                            </tr>`;
                    });

                    profileHTML += `</tbody></table>`;

                    if (Object.keys(minigameData.scores).length > 5) {
                        profileHTML += `
                            <button class="expand-button" onclick="toggleRows('minigame-table-${index}')">
                                <span class="expand-icon">â–²</span> Show Less
                            </button>`;
                    }

                    profileHTML += `</div>`;
                }
            });

            if (hasAnnotatedRecords) {
                profileHTML += `
                    <div class="legend">
                        * Indicates a score that is not reproducible in legitimate play at the current state of the map.
                    </div>
                `;
            }

            return profileHTML;
        }

        function toggleRows(tableId) {
            const table = document.getElementById(tableId);
            const button = table.nextElementSibling;
            const rows = table.querySelectorAll('tbody tr');

            const isExpanded = button.textContent.includes('Show Less');

            rows.forEach((row, index) => {
                if (index >= 5) {
                    row.style.display = isExpanded ? 'none' : 'table-row';
                }
            });

            if (isExpanded) {
                button.innerHTML = '<span class="expand-icon">â–¼</span> Show More';
            } else {
                button.innerHTML = '<span class="expand-icon">â–²</span> Show Less';
            }
        }

        function showPlayerProfile(playerName) {
            const modal = document.getElementById('player-profile-modal');
            const content = document.getElementById('player-profile-content');

            modal.style.display = 'block';
            content.innerHTML = '<div class="loading"><div class="spinner"></div></div>';
            document.title = `MCPR(${playerName})`;

            setTimeout(() => {
                content.innerHTML = createPlayerProfile(playerName);

                // Initialize collapsed tables
                const tables = content.querySelectorAll('.profile-table');
                tables.forEach((table, index) => {
                    if (table.rows.length > 6) { // 1 header + 5 data rows
                        toggleRows(`minigame-table-${index}`);
                    }
                });
            }, 500);
        }

        function closeModal() {
            document.getElementById('player-profile-modal').style.display = 'none';
            document.title = "Minecraft Party Records";
        }

        function setupGlobalSearch() {
            const searchInput = document.getElementById('global-player-search');
            const searchResults = document.getElementById('global-search-results');

            const performSearch = debounce(function() {
                const searchTerm = searchInput.value.toLowerCase();
                if (searchTerm.length < 2) {
                    searchResults.style.display = 'none';
                    return;
                }

                const matchingPlayers = Object.keys(playerUUIDs).filter(name =>
                    name.toLowerCase().includes(searchTerm)
                ).slice(0, 5);

                if (matchingPlayers.length > 0) {
                    searchResults.innerHTML = matchingPlayers.map((name, index) => `
                <div class="search-result-item ${index === 0 ? 'highlighted' : ''}"
                     data-player="${name}"
                     onclick="showPlayerProfile('${name}')">
                    <img src="https://crafatar.com/avatars/${playerUUIDs[name]}?size=32&overlay" alt="${name}'s avatar">
                    <span>${name}</span>
                </div>
            `).join('');
                    searchResults.style.display = 'block';
                } else {
                    searchResults.style.display = 'none';
                }
            }, 300);

            // Enhanced search input handler with Enter key support
            searchInput.addEventListener('input', performSearch);

            searchInput.addEventListener('keydown', function(event) {
                const searchTerm = this.value.trim();

                if (event.key === 'Enter') {
                    event.preventDefault();

                    if (searchTerm.length < 1) return;

                    // Get matching players
                    const matchingPlayers = Object.keys(playerUUIDs).filter(name =>
                        name.toLowerCase().includes(searchTerm.toLowerCase())
                    );

                    // Check for exact match first
                    const exactMatch = Object.keys(playerUUIDs).find(name =>
                        name.toLowerCase() === searchTerm.toLowerCase()
                    );

                    if (exactMatch) {
                        // Exact match found - show profile
                        console.log('Exact match found:', exactMatch);
                        showPlayerProfile(exactMatch);
                        this.value = '';
                        searchResults.style.display = 'none';
                    } else if (matchingPlayers.length === 1) {
                        // Only one match - show profile
                        console.log('Single match found:', matchingPlayers[0]);
                        showPlayerProfile(matchingPlayers[0]);
                        this.value = '';
                        searchResults.style.display = 'none';
                    } else if (matchingPlayers.length > 1) {
                        // Multiple matches - show the first one or keep search open
                        const highlightedItem = searchResults.querySelector('.highlighted');
                        if (highlightedItem) {
                            const playerName = highlightedItem.getAttribute('data-player');
                            console.log('Selected highlighted match:', playerName);
                            showPlayerProfile(playerName);
                            this.value = '';
                            searchResults.style.display = 'none';
                        } else {
                            // Just show search results if no highlight
                            performSearch();
                        }
                    } else {
                        // No matches found
                        console.log('No matches found for:', searchTerm);
                        // Could add a "no results" feedback here
                    }
                } else if (event.key === 'Escape') {
                    // Clear search and hide results
                    this.value = '';
                    searchResults.style.display = 'none';
                    this.blur();
                } else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    // Navigate through search results
                    event.preventDefault();
                    navigateSearchResults(event.key === 'ArrowDown' ? 1 : -1);
                }
            });

            // Click outside to close
            document.addEventListener('click', function(event) {
                if (!searchResults.contains(event.target) && event.target !== searchInput) {
                    searchResults.style.display = 'none';
                }
            });

            // Function to navigate search results with arrow keys
            function navigateSearchResults(direction) {
                const items = searchResults.querySelectorAll('.search-result-item');
                if (items.length === 0) return;

                const currentHighlighted = searchResults.querySelector('.highlighted');
                let newIndex = 0;

                if (currentHighlighted) {
                    const currentIndex = Array.from(items).indexOf(currentHighlighted);
                    newIndex = currentIndex + direction;

                    // Wrap around
                    if (newIndex < 0) newIndex = items.length - 1;
                    if (newIndex >= items.length) newIndex = 0;

                    currentHighlighted.classList.remove('highlighted');
                }

                items[newIndex].classList.add('highlighted');
            }
        }

        // Global hotkey handler
        function setupGlobalHotkeys() {
            document.addEventListener('keydown', function(event) {
                // Only handle global hotkeys if no input is focused and no modal is open
                const isInputFocused = document.activeElement && (
                    document.activeElement.tagName === 'INPUT' ||
                    document.activeElement.tagName === 'TEXTAREA' ||
                    document.activeElement.tagName === 'SELECT'
                );

                const isModalOpen = document.getElementById('player-profile-modal').style.display === 'block';

                // ESC key - close modal if open
                if (event.key === 'Escape') {
                    if (isModalOpen) {
                        event.preventDefault();
                        closeModal();
                        return;
                    }

                    // Also clear any focused inputs
                    if (isInputFocused) {
                        document.activeElement.blur();
                    }
                }

                // Enter key - focus search if no input is focused and no modal is open
                if (event.key === 'Enter' && !isInputFocused && !isModalOpen) {
                    event.preventDefault();
                    const searchInput = document.getElementById('global-player-search');
                    searchInput.focus();
                    console.log('Search focused via Enter hotkey');
                }

                // Forward slash (/) - also focus search (like GitHub, Reddit, etc.)
                if (event.key === '/' && !isInputFocused && !isModalOpen) {
                    event.preventDefault();
                    const searchInput = document.getElementById('global-player-search');
                    searchInput.focus();
                    console.log('Search focused via / hotkey');
                }
            });
        }


        function setupTableSearch() {
            const searchInput = document.getElementById('player-search');
            
            searchInput.addEventListener('input', function() {
                console.log('Table search:', this.value);
                if (gridApi) {
                    gridApi.setGridOption('quickFilterText', this.value);
                }
            });
        }

        // Data loading and initialization
        async function loadData() {
            console.log('Starting data loading...');
            
            try {
                // Load player UUIDs first
                console.log('Fetching player_uuids.json...');
                const uuidResponse = await fetch('data-analysis/player_uuids.json');
                if (!uuidResponse.ok) {
                    throw new Error(`Failed to load UUIDs: ${uuidResponse.status} ${uuidResponse.statusText}`);
                }
                playerUUIDs = await uuidResponse.json();
                console.log('Player UUIDs loaded:', Object.keys(playerUUIDs).length, 'players');

                // Load records data
                console.log('Fetching records_data.json...');
                const recordsResponse = await fetch('data-analysis/records_data.json');
                if (!recordsResponse.ok) {
                    throw new Error(`Failed to load records: ${recordsResponse.status} ${recordsResponse.statusText}`);
                }
                const recordsData = await recordsResponse.json();
                console.log('Records data loaded:', recordsData.length, 'records');

                // Load player info (optional, may not exist)
                try {
                    console.log('ðŸ“¡ Fetching player_data.json...');
                    const playerInfoResponse = await fetch('data-analysis/player_data.json');
                    if (playerInfoResponse.ok) {
                        playerInfoData = await playerInfoResponse.json();
                        console.log('Player info loaded:', Object.keys(playerInfoData).length, 'players');
                    } else {
                        console.log('! Player info not available, using defaults');
                        playerInfoData = {};
                    }
                } catch (error) {
                    console.log('! Player info not available:', error.message);
                    playerInfoData = {};
                }

                console.log('Data loading complete!');
                return recordsData;

            } catch (error) {
                console.error('! Error loading data:', error);
                
                // Fallback to sample data for testing
                console.log('ðŸ”„ Using sample data as fallback...');
                
                // Generate some sample UUIDs for testing
                playerUUIDs = {
                    "Ex4cted": "550e8400-e29b-41d4-a716-446655440000",
                    "swiffle": "550e8400-e29b-41d4-a716-446655440001", 
                    "juvona": "550e8400-e29b-41d4-a716-446655440002",
                    "__egE": "550e8400-e29b-41d4-a716-446655440003",
                    "TestPlayer1": "550e8400-e29b-41d4-a716-446655440004",
                    "TestPlayer2": "550e8400-e29b-41d4-a716-446655440005"
                };

                // Sample player info
                playerInfoData = {
                    "Ex4cted": {
                        rank: "premium",
                        minecraft_party: {
                            "Position (Punkte)": "42",
                            "Gewonnene Spiele": "150",
                            "Gespielte Spiele": "200", 
                            "Gewonnene Minispiele": "300",
                            "Gespielte Minispiele": "400"
                        }
                    }
                };

                // Enhanced sample data for testing
                const sampleData = [
                    {
                        "name": "Ex4cted",
                        "minigame": "Pferderennen",
                        "scores": {"City": 63.25, "Jungle": 71.5, "Ancient Falls": 85.2},
                        "best_score": 63.25
                    },
                    {
                        "name": "swiffle", 
                        "minigame": "Pferderennen",
                        "scores": {"City": 65.1, "Jungle": 69.8, "Ancient Falls": 82.3},
                        "best_score": 65.1
                    },
                    {
                        "name": "juvona",
                        "minigame": "Pferderennen", 
                        "scores": {"City": 67.8, "Jungle": 73.2},
                        "best_score": 67.8
                    },
                    {
                        "name": "__egE",
                        "minigame": "Sammelwahn",
                        "scores": {
                            "Sum": 452.0,
                            "Dichter Wald": 25.0,
                            " Bambusdschungel": 20.0,
                            " Birkenwald": 27.0,
                            " Blumenwald": 31.0
                        },
                        "best_score": 452.0
                    },
                    {
                        "name": "TestPlayer1",
                        "minigame": "Pferderennen",
                        "scores": {"City": 61.5, "Jungle": 68.9},
                        "best_score": 61.5  
                    },
                    {
                        "name": "TestPlayer2",
                        "minigame": "Pferderennen",
                        "scores": {"City": 70.2, "Ancient Falls": 88.1},
                        "best_score": 70.2
                    },
                    {
                        "name": "Ex4cted",
                        "minigame": "Runterpurzeln", 
                        "scores": {"Space": 49.26},
                        "best_score": 49.26
                    },
                    {
                        "name": "swiffle",
                        "minigame": "Runterpurzeln",
                        "scores": {"Space": 58.713},
                        "best_score": 58.713
                    }
                ];

                console.log('âœ… Sample data generated:', sampleData.length, 'records');
                return sampleData;
            }
        }

        // Grid initialization
        function initializeGrid() {
            console.log('ðŸ—ï¸ Initializing AG-Grid...');
            
            gridOptions = {
                columnDefs: [],
                rowData: [],
                defaultColDef: {
                    resizable: true,
                    sortable: true,
                    filter: false,
                    minWidth: 100
                },
                animateRows: true,
                rowHeight: 50,
                headerHeight: 40,
                suppressRowClickSelection: true,
                enableCellTextSelection: true,
                onGridReady: function(params) {
                    console.log('Grid ready, API available');
                    gridApi = params.api;
                    updateGrid(currentMinigame);
                },
                onSortChanged: function() {
                    console.log('Sort changed, updating ranks...');
                    updateRanksAfterSort();
                },
                onFirstDataRendered: function() {
                    console.log('First data rendered');
                    // Auto-size the name column first to fit content
                    gridApi.autoSizeColumns(['name'], false);
                    
                    // Then fit the remaining columns
                    setTimeout(() => {
                        gridApi.sizeColumnsToFit();
                    }, 50);
                },
                onGridSizeChanged: function() {
                    // When grid is resized, maintain name column width and resize others
                    setTimeout(() => {
                        gridApi.autoSizeColumns(['name'], false);
                        setTimeout(() => {
                            gridApi.sizeColumnsToFit();
                        }, 50);
                    }, 100);
                }
            };

            const gridDiv = document.getElementById('records-grid');
            console.log('Creating grid in element:', gridDiv);
            
            // Use the new createGrid API instead of deprecated new Grid()
            const gridInstance = agGrid.createGrid(gridDiv, gridOptions);
            gridApi = gridInstance;
            
            console.log('AG-Grid initialized successfully');
        }

        function updateRanksAfterSort() {
            if (!gridApi) return;

            let rank = 1;
            let lastScore = null;
            let tieCount = 0;

            gridApi.forEachNodeAfterFilterAndSort((node, index) => {
                const sortedColumns = gridApi.getColumnState().filter(col => col.sort);
                if (sortedColumns.length > 0) {
                    const sortCol = sortedColumns[0];
                    const score = node.data.scores && node.data.scores[sortCol.colId.replace('scores.', '')];

                    if (lastScore !== null && score !== lastScore) {
                        rank += tieCount + 1;
                        tieCount = 0;
                    } else if (lastScore !== null) {
                        tieCount++;
                    }

                    node.setDataValue('rank', rank);
                    lastScore = score;
                }
            });
        }

        const artisticFonts = [
            // Futuristic Abstracts
            { name: "'Orbitron', monospace", style: "space-age-bold" },
            { name: "'Audiowide', sans-serif", style: "digital-wide" },
            { name: "'Electrolize', sans-serif", style: "electric-modern" },
            { name: "'Michroma', sans-serif", style: "chrome-abstract" },
            { name: "'Monoton', monospace", style: "neon-outline" },
            { name: "'Syncopate', sans-serif", style: "spaced-rhythm" },
            { name: "'Megrim', cursive", style: "stencil-abstract" },
            { name: "'Aldrich', sans-serif", style: "matrix-minimal" },
            { name: "'Share Tech', sans-serif", style: "tech-share" },
            { name: "'Exo', sans-serif", style: "exo-modern" },
            { name: "'Rajdhani', sans-serif", style: "indian-tech" },
            { name: "'Space Mono', monospace", style: "space-typewriter" },
            { name: "'Oxanium', sans-serif", style: "gaming-abstract" },

            // Bold Display Abstracts
            { name: "'Bebas Neue', cursive", style: "condensed-impact" },
            { name: "'Righteous', cursive", style: "comic-modern" },
            { name: "'Russo One', sans-serif", style: "russian-bold" },
            { name: "'Changa One', cursive", style: "arabic-bold" },
            { name: "'Stalinist One', cursive", style: "propaganda-modern" },
            { name: "'Black Ops One', cursive", style: "military-stencil" },
            { name: "'Faster One', cursive", style: "speed-abstract" },
            { name: "'Gruppo', cursive", style: "italian-condensed" },
            { name: "'Jockey One', cursive", style: "racing-modern" },
            { name: "'Abril Fatface', cursive", style: "fat-serif-modern" },
            { name: "'Ultra', serif", style: "ultra-bold-serif" },
            { name: "'Bowlby One', cursive", style: "3d-bold" },
            { name: "'Bowlby One SC', cursive", style: "small-caps-3d" },

            // Geometric Abstracts
            { name: "'Bungee', cursive", style: "urban-geometric" },
            { name: "'Bungee Shade', cursive", style: "3d-shadow-modern" },
            { name: "'Bungee Outline', cursive", style: "outline-geometric" },
            { name: "'Bungee Inline', cursive", style: "inline-modern" },
            { name: "'Bungee Hairline', cursive", style: "hairline-modern" },
            { name: "'Poiret One', cursive", style: "art-deco-thin" },

            // Gothic Modern
            { name: "'Creepster', cursive", style: "horror-modern" },
            { name: "'Butcherman', cursive", style: "brutal-modern" },
            { name: "'Eater', cursive", style: "decay-abstract" },
            { name: "'Metal Mania', cursive", style: "metal-modern" },
            { name: "'Vampiro One', cursive", style: "elegant-gothic" },
            { name: "'UnifrakturMaguntia', cursive", style: "blackletter-modern" },
            { name: "'MedievalSharp', cursive", style: "medieval-abstract" },

            // Decorative Modern
            { name: "'Caesar Dressing', cursive", style: "roman-playful" },
            { name: "'Fascinate', cursive", style: "art-deco-modern" },
            { name: "'Fascinate Inline', cursive", style: "deco-inline" },
            { name: "'Metamorphous', cursive", style: "butterfly-modern" },
            { name: "'Snowburst One', cursive", style: "winter-burst" },
            { name: "'Flavors', cursive", style: "ice-cream-modern" },
            { name: "'Lacquer', cursive", style: "asian-modern" },
            { name: "'Cinzel Decorative', cursive", style: "roman-decorative" },
            { name: "'Almendra Display', cursive", style: "vintage-modern" },
            { name: "'Fredericka the Great', cursive", style: "royal-modern" },

            // Adventure Modern
            { name: "'Trade Winds', cursive", style: "tropical-modern" },
            { name: "'Pirata One', cursive", style: "pirate-modern" },
            { name: "'Jolly Lodger', cursive", style: "tavern-modern" },
            { name: "'New Rocker', cursive", style: "grunge-modern" },
            { name: "'Fontdiner Swanky', cursive", style: "diner-modern" },
            { name: "'Macondo', cursive", style: "magical-modern" },
            { name: "'Macondo Swash Caps', cursive", style: "magical-swash" },
            { name: "'Spicy Rice', cursive", style: "asian-spice" },

            // Playful Modern
            { name: "'Underdog', cursive", style: "cartoon-modern" },
            { name: "'Henny Penny', cursive", style: "chicken-modern" },
            { name: "'Bangers', cursive", style: "comic-explosion" },
            { name: "'Luckiest Guy', cursive", style: "lucky-modern" },
            { name: "'Freckle Face', cursive", style: "freckled-fun" },
            { name: "'Kranky', cursive", style: "quirky-modern" },
            { name: "'Ewert', cursive", style: "stencil-playful" },
            { name: "'Skranji', cursive", style: "grunge-casual" },

            // Retro Modern
            { name: "'Special Elite', cursive", style: "typewriter-modern" },
            { name: "'Press Start 2P', monospace", style: "pixel-modern" },
            { name: "'VT323', monospace", style: "terminal-modern" },
            { name: "'Wallpoet', cursive", style: "graffiti-modern" }
        ];

        function setRandomFont() {
            const titleElement = document.querySelector('.main-title');
            if (!titleElement) return;

            // Pick the final font that we'll end up with
            const finalFont = artisticFonts[Math.floor(Math.random() * artisticFonts.length)];

            // Create a shuffled array of fonts to cycle through
            const shuffledFonts = [...artisticFonts].sort(() => Math.random() - 0.5);

            let currentIndex = 0;
            const cycleDuration = 200; // Total time for the cycling in ms
            const totalCycles = 10; // Number of fonts to cycle through

            // Calculate intervals - start fast, then slow down
            const intervals = [];
            for (let i = 0; i < totalCycles; i++) {
                // Exponential slowdown: starts at 50ms, gradually increases to 300ms
                const progress = i / (totalCycles - 1);
                const interval = 20 + (30 * Math.pow(progress, 2));
                intervals.push(interval);
            }

            console.log('Starting font carousel...');

            // Function to update to next font in cycle
            function cycleFont() {
                if (currentIndex < totalCycles) {
                    const currentFont = shuffledFonts[currentIndex % shuffledFonts.length];
                    titleElement.style.fontFamily = currentFont.name;

                    // Add a subtle flash effect during cycling
                    titleElement.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        titleElement.style.transform = 'scale(1)';
                    }, intervals[currentIndex] / 2);

                    currentIndex++;

                    // Schedule next font change with increasing delay
                    setTimeout(cycleFont, intervals[currentIndex - 1]);
                } else {
                    // Cycling complete - set final font with a special effect
                    setTimeout(() => {
                        titleElement.style.fontFamily = finalFont.name;

                        setTimeout(() => {
                            titleElement.style.transform = 'scale(1)';
                            titleElement.style.textShadow = '';
                        }, 400);

                        console.log(`Font carousel complete! Final selection: ${finalFont.name} (${finalFont.style})`);
                    }, 200);
                }
            }

            // Start the carousel
            titleElement.style.transition = 'all 0.1s ease';
            cycleFont();

            // Reset transition after carousel completes
            setTimeout(() => {
                titleElement.style.transition = 'all 0.4s ease';
            }, cycleDuration + 1000);
        }

        function setupEventListeners() {
            document.getElementById('minigame-select').addEventListener('change', function() {
                updateGrid(this.value);
            });

            document.getElementById('close-modal').addEventListener('click', closeModal);

            document.getElementById('player-profile-modal').addEventListener('click', function(event) {
                if (event.target === this) {
                    closeModal();
                }
            });

            // Set up global hotkeys and hints
            setupGlobalHotkeys();
            setupHotkeyHints();

            console.log('Hotkeys enabled: ESC (close modal), ENTER (focus search), / (focus search)');
        }

        // Main initialization
        async function init() {
            console.log('Starting application initialization...');
            document.getElementById('loading-animation').style.display = 'flex';
            
            try {
                allData = await loadData();
                console.log('Total data loaded:', allData.length, 'records');
                
                // Log minigames available
                const minigames = [...new Set(allData.map(record => record.minigame))];
                console.log('Available minigames:', minigames);
                
                initializeGrid();
                setupGlobalSearch();
                setupTableSearch();
                setupEventListeners();
                
                document.getElementById('loading-animation').style.display = 'none';
                document.getElementById('records-grid').classList.add('loaded');
                
                console.log('Application initialization complete!');
            } catch (error) {
                console.error('! Initialization failed:', error);
                document.getElementById('loading-animation').style.display = 'none';
                
                // Show error message
                document.getElementById('records-grid').innerHTML = `
                    <div style="padding: 20px; text-align: center; color: var(--text-color);">
                        <h3>Error loading data</h3>
                        <p>Please check the console for details and ensure data files are available.</p>
                        <p style="font-size: 0.9em; color: #888;">${error.message}</p>
                    </div>
                `;
            }

            // Apply random font to title
            setRandomFont();

            document.getElementById('loading-animation').style.display = 'flex';
        }

        // Make functions globally available
        window.showPlayerProfile = showPlayerProfile;
        window.closeModal = closeModal;
        window.toggleRows = toggleRows;

        // Start the application
        document.addEventListener('DOMContentLoaded', init);

        // Hotkey hint management
        function setupHotkeyHints() {
            const hints = document.getElementById('hotkey-hints');
            const escapeHint = document.getElementById('hint-escape');
            const searchHints = document.querySelectorAll('#hint-search, #hint-search-alt');

            // Show/hide escape hint based on modal state
            function updateHints() {
                const isModalOpen = document.getElementById('player-profile-modal').style.display === 'block';

                if (isModalOpen) {
                    // Show escape hint, hide search hints
                    escapeHint.style.display = 'flex';
                    searchHints.forEach(hint => {
                        hint.classList.add('modal-open');
                    });
                } else {
                    // Hide escape hint, show search hints
                    escapeHint.style.display = 'none';
                    searchHints.forEach(hint => {
                        hint.classList.remove('modal-open');
                    });
                }
            }

            // Create observer for modal changes
            const modal = document.getElementById('player-profile-modal');
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                        updateHints();
                    }
                });
            });

            observer.observe(modal, { attributes: true });

            // Initial update
            updateHints();

            // Hide hints temporarily when user starts typing
            const searchInput = document.getElementById('global-player-search');
            let hideTimeout;

            searchInput.addEventListener('focus', function() {
                clearTimeout(hideTimeout);
                searchHints.forEach(hint => hint.style.opacity = '0.3');
            });

            searchInput.addEventListener('blur', function() {
                hideTimeout = setTimeout(() => {
                    searchHints.forEach(hint => hint.style.opacity = '');
                }, 1000);
            });

            console.log('Hotkey hints initialized');
        }
    </script>

    <!-- Hotkey Hints -->
    <div class="hotkey-hints" id="hotkey-hints">
        <div class="hotkey-hint" id="hint-search">
            <span class="hotkey-key">Enter</span>
            <span>Focus search</span>
        </div>
        <div class="hotkey-hint" id="hint-search-alt">
            <span class="hotkey-key">/</span>
            <span>Quick search</span>
        </div>
        <div class="hotkey-hint modal-hint" id="hint-escape" style="display: none;">
            <span class="hotkey-key">Esc</span>
            <span>Close modal</span>
        </div>
    </div>

</body>
</html>